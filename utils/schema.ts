// Fix: Use a named import for `z` from `zod` as the library exports it this way.
import { z } from 'zod';
import { NODE_TYPE_COLORS } from '../constants';

// Extract valid node types from the constants to be used in the enum.
const validNodeTypes = Object.keys(NODE_TYPE_COLORS) as [string, ...string[]];

// Schema for a subject or object node ('s' or 'o').
// It must have a non-empty label.
// The 'type' is preprocessed: if the incoming type from the JSON is not in our
// predefined list of valid types, it gracefully falls back to 'default' instead
// of throwing a validation error. This makes the app more resilient to
// unexpected types generated by the AI.
const S_O_NodeSchema = z.object({
  label: z.string().min(1, { message: "Node label cannot be empty." }),
  type: z.preprocess(
    (val) => (typeof val === 'string' && validNodeTypes.includes(val) ? val : 'default'),
    z.enum(validNodeTypes)
  ),
});

// Schema for a single triplet, containing a subject, predicate, and a nullable object.
const TripletSchema = z.object({
  s: S_O_NodeSchema,
  p: z.string().min(1, { message: "Predicate 'p' cannot be empty." }),
  o: S_O_NodeSchema.nullable(),
  source_quote: z.string().optional(),
});

// The main schema for the triplet JSON object.
export const TripletJsonDataSchema = z.object({
  triplets: z.array(TripletSchema),
});


// Schemas for the new Knowledge Base format
const RelatedConceptSchema = z.object({
  typ: z.enum(["prerequisite", "co-requisite", "application"]),
  c_id: z.string().min(1, { message: "Related concept c_id cannot be empty." }),
});

const KnowledgeNuggetSchema = z.object({
  nug: z.string(),
  s_quo: z.string(),
});

// --- Preprocessing Maps for Robustness ---
// These maps allow the schema to accept common English terms from the AI
// and normalize them to the expected Portuguese enum values.
const complexityMap = {
    "Low": "Baixa", "Medium": "Média", "High": "Alta",
    "Baixa": "Baixa", "Média": "Média", "Alta": "Alta"
};
const relevanceMap = {
    "Fundamental": "Fundamental", "Important": "Importante", "Specialized": "Especializado",
    "Importante": "Importante", "Especializado": "Especializado"
};
const stabilityMap = {
    "Stable": "Estável", "Emerging": "Emergente",
    "Estável": "Estável", "Emergente": "Emergente"
};


const KnowledgeBaseConceptSchema = z.object({
  c_id: z.string().min(1, { message: "Concept c_id cannot be empty." }),
  s_doc: z.string(),
  c_con: z.string(),
  k_nug: z.array(KnowledgeNuggetSchema),
  p_misc: z.array(z.string()),
  b_lvl: z.array(z.string()),
  c_cplx: z.preprocess(
    (val) => typeof val === 'string' && val in complexityMap ? complexityMap[val as keyof typeof complexityMap] : val,
    z.enum(["Baixa", "Média", "Alta"])
  ),
  c_rel: z.preprocess(
    (val) => typeof val === 'string' && val in relevanceMap ? relevanceMap[val as keyof typeof relevanceMap] : val,
    z.enum(["Fundamental", "Importante", "Especializado"])
  ),
  k_stab: z.preprocess(
      (val) => typeof val === 'string' && val in stabilityMap ? stabilityMap[val as keyof typeof stabilityMap] : val,
      z.enum(["Estável", "Emergente"])
  ),
  r_con: z.array(RelatedConceptSchema),
  m_prmpt: z.array(z.string()),
});

export const KnowledgeBaseJsonDataSchema = z.object({
  kb: z.array(KnowledgeBaseConceptSchema),
});

// Schemas for the new direct graph format
export const GraphNodeSchema = z.object({
    id: z.string().min(1),
    label: z.string().min(1),
    type: z.string(),
    source_quote: z.string().optional(),
});

export const GraphEdgeSchema = z.object({
    id: z.string().min(1),
    source: z.string().min(1),
    target: z.string().min(1),
    label: z.string().optional(),
});

export const GraphJsonDataSchema = z.object({
    result: z.object({
        title: z.string(),
        nodes: z.array(GraphNodeSchema),
        edges: z.array(GraphEdgeSchema),
    }),
});