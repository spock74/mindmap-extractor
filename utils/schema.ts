// Fix: Use a named import for `z` from `zod` as the library exports it this way.
import { z } from 'zod';
import { NODE_TYPE_COLORS } from '../constants';

// Extract valid node types from the constants to be used in the enum.
const validNodeTypes = Object.keys(NODE_TYPE_COLORS) as [string, ...string[]];

// Schema for a subject or object node ('s' or 'o').
// It must have a non-empty label.
// The 'type' is preprocessed: if the incoming type from the JSON is not in our
// predefined list of valid types, it gracefully falls back to 'default' instead
// of throwing a validation error. This makes the app more resilient to
// unexpected types generated by the AI.
const S_O_NodeSchema = z.object({
  label: z.string().min(1, { message: "Node label cannot be empty." }),
  type: z.preprocess(
    (val) => (typeof val === 'string' && validNodeTypes.includes(val) ? val : 'default'),
    z.enum(validNodeTypes)
  ),
});

// Schema for a single triplet, containing a subject, predicate, and a nullable object.
const TripletSchema = z.object({
  s: S_O_NodeSchema,
  p: z.string().min(1, { message: "Predicate 'p' cannot be empty." }),
  o: S_O_NodeSchema.nullable(),
});

// The main schema for the entire JSON object.
// It expects a root object with a 'triplets' key which is an array of our TripletSchema.
export const JsonDataSchema = z.object({
  triplets: z.array(TripletSchema),
});
